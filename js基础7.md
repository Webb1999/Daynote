##### 46.构造函数修改

创建一个Person构造函数

​	在Person构造函数中，为每一个对象都添加了一个sayName方法，目前我们的方法是在构造函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法，也是所有实例的sayName都是唯一的

​	这就导致了构造函数执行一次就创建一个新的方法，执行一万次就有一万个方法，而一万个方法都是一样的，这是完全没必要的，可使所有的对象共享一个方法

```
function Person(){
	this.sayName=fun;
}
将方法定义在全局作用域
将函数定义在全局作用域，污染了全局作用域的命名空间，而且定义在全局作用域中也很不安全
function fun(){
console.log("name:"+ this.name);
}
```

##### 47.原型

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype

这个属性对应着一个对象，这个对象就是我们所谓的原型对象，如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，他所创建的对象都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过

```
__proto__(两个下划线)来访问该属性
原型对象就相当于一个公共的区域，所有的同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中
当我们访问对象的一个属性或方法时，会现在自身中寻找，有就直接使用，没有就找原型对象里找，有就使用

Person.prototype.sayName = function(){
console.log("name:" + this.name);
}
以后我们创建构造函数时，可以将这些对象共有的属性和方法，同意统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法。

使用in检查对象是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
可以使用对象的hasOwnProperty()来检查对象自身是否含有该属性，只有对象自身含有该属性时，才会返回true
原型对象也是对象，他也有原型
	当我们使用一个对象的属性或方法时，如果没有，去原型里找，如果还没有就去原型的原型里找，直到找到Object对象的原型，Object对象的原型没有原型，如果还没有，则返回undefined
	
```

##### 48.toString（）

当我们直接在页面中打印一个对象时，实际上输出的对象是toString（）方法的返回值，如果我们希望在输出对象时不要输出[Object Object],可以为对象添加一个toString（）方法

##### 49.垃圾回收

时间长了，程序运行过程中也会产生垃圾，这些垃圾积攒过多，会导致程序运行速度过慢，所以需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾，当一个对象没有任何的变量或属性对他进行引用，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以必须清理。

在js中拥有自动的垃圾回收机制，会自动讲这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作

我们需要做的只是将不在使用的对象设置成null即可

##### 50.数组

数组

​		也是一个对象

​		和普通对象功能相似，也是用来存储一些值

​		不同的是普通对象使用字符串作为属性名，数组使用数字作为索引操作元素

​		索引：从0开始的整数就是索引

​		数组的存储型性能比普通对象好，开发中经常使用数组来存储一些数据

```
创建数组对象
var arr = new Array();Object类型
向数组中添加元素
arr[0]=10;
arr[1]=12;
读取元素
console.log(arr[0]);
获取数组的长度
console.log(arr.length);
对于非连续的数组，length会获得最大索引+1
尽量不要创建非连续的数组
arr.length = 10;
修改length，如果修改的length大于原长度，多出部分会空出来，若小于原长度，多出元素会被删除
向数组最后一个位置添加元素
arr[arr.length]=78;

```

##### 51.数组字面量

```
使用字面量来创建数组,可以在创建时就指定数组中的元素
var arr= [1,2,3,4,5,6];
使用构造函数创建数组
var arr2= new Array(2,4,6);
创建一个数组，数组中只有一个元素
arr = [20];
创建一个长度为10的数组
arr2 = new Array(10);
数组中的元素可以是任意的数据类型
任意数据类型、对象、函数、数组都可以
```

##### 52.数组的四个方法

```
push()
该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度
可以将添加的元素作为方法的参数传递
这样这些元素会自动添加到数组的末尾
var result = arr.push("唐僧","白骨精","蜘蛛精");//返回新的长度
pop()
删除最后一个元素，并作为返回值返回
unshift()
向数组开头添加一个或多个元素，并返回新的数组长度
shift()
删除第一个元素并将之作为返回值返回
```

##### 53.数组的遍历

```
var arr =["孙悟空","猪八戒","沙和尚"];
所谓的遍历数组，就是将数组所有的元素取出来

练习： <script>
        function Person(name,age){
            this.name=name;
            this.age=age;
        }
        Person.prototype.toString=function(){
            return "Person[name="+thi.name+",age="+this.age+"]";
        }
        var per=new Person("孙悟空","14");
        var per2=new Person("猪八戒","23");
        var per3=new Person("沙和尚","16");
        var per4=new Person("唐僧","38");

        var perArr=[per,per2,per3,per4];
        //创建一个数组将成年的（大于18岁）的Person提取出来
        function getAdult(arr1){
            var arr=[];
            var j=0;
            for(var i=0;i<perArr.length;i++){
                if(perArr[i].age>18){
                    arr.push(perArr[i]);
                }
            }
            return arr;
        }
        console.log(perArr[2].age);
        var result = getAdult(perArr);
        console.log(result);
    </script>
```

##### 54.for-each

```
遍历数组
arr.foreach();//IE8及以下不支持
需要一个函数作为参数,由我们创建但是不是我们调用的，称为回调函数，这个数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容，浏览器会在回调函数中传递三个参数，
第一个是当前正在遍历的元素，
第二个参数是索引。
第三个是正在遍历的数组
arr.foreach(function()){
	
}
```

